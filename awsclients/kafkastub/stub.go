// Generated by github.com/temporalio/temporal-aws-sdk-generator
// from github.com/aws/aws-sdk-go version 1.35.7
// Copyright (c) 2020 Temporal Technologies Inc.  All rights reserved.

package kafkastub

import (
	"github.com/aws/aws-sdk-go/service/kafka"
    "go.temporal.io/aws-sdk/awsclients"
	"go.temporal.io/sdk/workflow"

)

// ensure that imports are valid even if not used by the generated code
var _ awsclients.VoidFuture

type stub struct{}

type KafkaBatchAssociateScramSecretFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaBatchAssociateScramSecretFuture) Get(ctx workflow.Context) (*kafka.BatchAssociateScramSecretOutput, error) {
	var output kafka.BatchAssociateScramSecretOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaBatchDisassociateScramSecretFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaBatchDisassociateScramSecretFuture) Get(ctx workflow.Context) (*kafka.BatchDisassociateScramSecretOutput, error) {
	var output kafka.BatchDisassociateScramSecretOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaCreateClusterFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaCreateClusterFuture) Get(ctx workflow.Context) (*kafka.CreateClusterOutput, error) {
	var output kafka.CreateClusterOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaCreateConfigurationFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaCreateConfigurationFuture) Get(ctx workflow.Context) (*kafka.CreateConfigurationOutput, error) {
	var output kafka.CreateConfigurationOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaDeleteClusterFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaDeleteClusterFuture) Get(ctx workflow.Context) (*kafka.DeleteClusterOutput, error) {
	var output kafka.DeleteClusterOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaDeleteConfigurationFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaDeleteConfigurationFuture) Get(ctx workflow.Context) (*kafka.DeleteConfigurationOutput, error) {
	var output kafka.DeleteConfigurationOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaDescribeClusterFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaDescribeClusterFuture) Get(ctx workflow.Context) (*kafka.DescribeClusterOutput, error) {
	var output kafka.DescribeClusterOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaDescribeClusterOperationFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaDescribeClusterOperationFuture) Get(ctx workflow.Context) (*kafka.DescribeClusterOperationOutput, error) {
	var output kafka.DescribeClusterOperationOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaDescribeConfigurationFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaDescribeConfigurationFuture) Get(ctx workflow.Context) (*kafka.DescribeConfigurationOutput, error) {
	var output kafka.DescribeConfigurationOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaDescribeConfigurationRevisionFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaDescribeConfigurationRevisionFuture) Get(ctx workflow.Context) (*kafka.DescribeConfigurationRevisionOutput, error) {
	var output kafka.DescribeConfigurationRevisionOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaGetBootstrapBrokersFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaGetBootstrapBrokersFuture) Get(ctx workflow.Context) (*kafka.GetBootstrapBrokersOutput, error) {
	var output kafka.GetBootstrapBrokersOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaGetCompatibleKafkaVersionsFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaGetCompatibleKafkaVersionsFuture) Get(ctx workflow.Context) (*kafka.GetCompatibleKafkaVersionsOutput, error) {
	var output kafka.GetCompatibleKafkaVersionsOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaListClusterOperationsFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaListClusterOperationsFuture) Get(ctx workflow.Context) (*kafka.ListClusterOperationsOutput, error) {
	var output kafka.ListClusterOperationsOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaListClustersFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaListClustersFuture) Get(ctx workflow.Context) (*kafka.ListClustersOutput, error) {
	var output kafka.ListClustersOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaListConfigurationRevisionsFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaListConfigurationRevisionsFuture) Get(ctx workflow.Context) (*kafka.ListConfigurationRevisionsOutput, error) {
	var output kafka.ListConfigurationRevisionsOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaListConfigurationsFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaListConfigurationsFuture) Get(ctx workflow.Context) (*kafka.ListConfigurationsOutput, error) {
	var output kafka.ListConfigurationsOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaListKafkaVersionsFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaListKafkaVersionsFuture) Get(ctx workflow.Context) (*kafka.ListKafkaVersionsOutput, error) {
	var output kafka.ListKafkaVersionsOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaListNodesFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaListNodesFuture) Get(ctx workflow.Context) (*kafka.ListNodesOutput, error) {
	var output kafka.ListNodesOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaListScramSecretsFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaListScramSecretsFuture) Get(ctx workflow.Context) (*kafka.ListScramSecretsOutput, error) {
	var output kafka.ListScramSecretsOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaListTagsForResourceFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaListTagsForResourceFuture) Get(ctx workflow.Context) (*kafka.ListTagsForResourceOutput, error) {
	var output kafka.ListTagsForResourceOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaRebootBrokerFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaRebootBrokerFuture) Get(ctx workflow.Context) (*kafka.RebootBrokerOutput, error) {
	var output kafka.RebootBrokerOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaTagResourceFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaTagResourceFuture) Get(ctx workflow.Context) (*kafka.TagResourceOutput, error) {
	var output kafka.TagResourceOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaUntagResourceFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaUntagResourceFuture) Get(ctx workflow.Context) (*kafka.UntagResourceOutput, error) {
	var output kafka.UntagResourceOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaUpdateBrokerCountFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaUpdateBrokerCountFuture) Get(ctx workflow.Context) (*kafka.UpdateBrokerCountOutput, error) {
	var output kafka.UpdateBrokerCountOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaUpdateBrokerStorageFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaUpdateBrokerStorageFuture) Get(ctx workflow.Context) (*kafka.UpdateBrokerStorageOutput, error) {
	var output kafka.UpdateBrokerStorageOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaUpdateClusterConfigurationFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaUpdateClusterConfigurationFuture) Get(ctx workflow.Context) (*kafka.UpdateClusterConfigurationOutput, error) {
	var output kafka.UpdateClusterConfigurationOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaUpdateClusterKafkaVersionFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaUpdateClusterKafkaVersionFuture) Get(ctx workflow.Context) (*kafka.UpdateClusterKafkaVersionOutput, error) {
	var output kafka.UpdateClusterKafkaVersionOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaUpdateConfigurationFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaUpdateConfigurationFuture) Get(ctx workflow.Context) (*kafka.UpdateConfigurationOutput, error) {
	var output kafka.UpdateConfigurationOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type KafkaUpdateMonitoringFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *KafkaUpdateMonitoringFuture) Get(ctx workflow.Context) (*kafka.UpdateMonitoringOutput, error) {
	var output kafka.UpdateMonitoringOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

func (a *stub) BatchAssociateScramSecret(ctx workflow.Context, input *kafka.BatchAssociateScramSecretInput) (*kafka.BatchAssociateScramSecretOutput, error) {
	var output kafka.BatchAssociateScramSecretOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.BatchAssociateScramSecret", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) BatchAssociateScramSecretAsync(ctx workflow.Context, input *kafka.BatchAssociateScramSecretInput) *KafkaBatchAssociateScramSecretFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.BatchAssociateScramSecret", input)
	return &KafkaBatchAssociateScramSecretFuture{Future: future}
}

func (a *stub) BatchDisassociateScramSecret(ctx workflow.Context, input *kafka.BatchDisassociateScramSecretInput) (*kafka.BatchDisassociateScramSecretOutput, error) {
	var output kafka.BatchDisassociateScramSecretOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.BatchDisassociateScramSecret", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) BatchDisassociateScramSecretAsync(ctx workflow.Context, input *kafka.BatchDisassociateScramSecretInput) *KafkaBatchDisassociateScramSecretFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.BatchDisassociateScramSecret", input)
	return &KafkaBatchDisassociateScramSecretFuture{Future: future}
}

func (a *stub) CreateCluster(ctx workflow.Context, input *kafka.CreateClusterInput) (*kafka.CreateClusterOutput, error) {
	var output kafka.CreateClusterOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.CreateCluster", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) CreateClusterAsync(ctx workflow.Context, input *kafka.CreateClusterInput) *KafkaCreateClusterFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.CreateCluster", input)
	return &KafkaCreateClusterFuture{Future: future}
}

func (a *stub) CreateConfiguration(ctx workflow.Context, input *kafka.CreateConfigurationInput) (*kafka.CreateConfigurationOutput, error) {
	var output kafka.CreateConfigurationOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.CreateConfiguration", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) CreateConfigurationAsync(ctx workflow.Context, input *kafka.CreateConfigurationInput) *KafkaCreateConfigurationFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.CreateConfiguration", input)
	return &KafkaCreateConfigurationFuture{Future: future}
}

func (a *stub) DeleteCluster(ctx workflow.Context, input *kafka.DeleteClusterInput) (*kafka.DeleteClusterOutput, error) {
	var output kafka.DeleteClusterOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.DeleteCluster", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) DeleteClusterAsync(ctx workflow.Context, input *kafka.DeleteClusterInput) *KafkaDeleteClusterFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.DeleteCluster", input)
	return &KafkaDeleteClusterFuture{Future: future}
}

func (a *stub) DeleteConfiguration(ctx workflow.Context, input *kafka.DeleteConfigurationInput) (*kafka.DeleteConfigurationOutput, error) {
	var output kafka.DeleteConfigurationOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.DeleteConfiguration", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) DeleteConfigurationAsync(ctx workflow.Context, input *kafka.DeleteConfigurationInput) *KafkaDeleteConfigurationFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.DeleteConfiguration", input)
	return &KafkaDeleteConfigurationFuture{Future: future}
}

func (a *stub) DescribeCluster(ctx workflow.Context, input *kafka.DescribeClusterInput) (*kafka.DescribeClusterOutput, error) {
	var output kafka.DescribeClusterOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.DescribeCluster", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) DescribeClusterAsync(ctx workflow.Context, input *kafka.DescribeClusterInput) *KafkaDescribeClusterFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.DescribeCluster", input)
	return &KafkaDescribeClusterFuture{Future: future}
}

func (a *stub) DescribeClusterOperation(ctx workflow.Context, input *kafka.DescribeClusterOperationInput) (*kafka.DescribeClusterOperationOutput, error) {
	var output kafka.DescribeClusterOperationOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.DescribeClusterOperation", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) DescribeClusterOperationAsync(ctx workflow.Context, input *kafka.DescribeClusterOperationInput) *KafkaDescribeClusterOperationFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.DescribeClusterOperation", input)
	return &KafkaDescribeClusterOperationFuture{Future: future}
}

func (a *stub) DescribeConfiguration(ctx workflow.Context, input *kafka.DescribeConfigurationInput) (*kafka.DescribeConfigurationOutput, error) {
	var output kafka.DescribeConfigurationOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.DescribeConfiguration", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) DescribeConfigurationAsync(ctx workflow.Context, input *kafka.DescribeConfigurationInput) *KafkaDescribeConfigurationFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.DescribeConfiguration", input)
	return &KafkaDescribeConfigurationFuture{Future: future}
}

func (a *stub) DescribeConfigurationRevision(ctx workflow.Context, input *kafka.DescribeConfigurationRevisionInput) (*kafka.DescribeConfigurationRevisionOutput, error) {
	var output kafka.DescribeConfigurationRevisionOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.DescribeConfigurationRevision", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) DescribeConfigurationRevisionAsync(ctx workflow.Context, input *kafka.DescribeConfigurationRevisionInput) *KafkaDescribeConfigurationRevisionFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.DescribeConfigurationRevision", input)
	return &KafkaDescribeConfigurationRevisionFuture{Future: future}
}

func (a *stub) GetBootstrapBrokers(ctx workflow.Context, input *kafka.GetBootstrapBrokersInput) (*kafka.GetBootstrapBrokersOutput, error) {
	var output kafka.GetBootstrapBrokersOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.GetBootstrapBrokers", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) GetBootstrapBrokersAsync(ctx workflow.Context, input *kafka.GetBootstrapBrokersInput) *KafkaGetBootstrapBrokersFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.GetBootstrapBrokers", input)
	return &KafkaGetBootstrapBrokersFuture{Future: future}
}

func (a *stub) GetCompatibleKafkaVersions(ctx workflow.Context, input *kafka.GetCompatibleKafkaVersionsInput) (*kafka.GetCompatibleKafkaVersionsOutput, error) {
	var output kafka.GetCompatibleKafkaVersionsOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.GetCompatibleKafkaVersions", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) GetCompatibleKafkaVersionsAsync(ctx workflow.Context, input *kafka.GetCompatibleKafkaVersionsInput) *KafkaGetCompatibleKafkaVersionsFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.GetCompatibleKafkaVersions", input)
	return &KafkaGetCompatibleKafkaVersionsFuture{Future: future}
}

func (a *stub) ListClusterOperations(ctx workflow.Context, input *kafka.ListClusterOperationsInput) (*kafka.ListClusterOperationsOutput, error) {
	var output kafka.ListClusterOperationsOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.ListClusterOperations", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) ListClusterOperationsAsync(ctx workflow.Context, input *kafka.ListClusterOperationsInput) *KafkaListClusterOperationsFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.ListClusterOperations", input)
	return &KafkaListClusterOperationsFuture{Future: future}
}

func (a *stub) ListClusters(ctx workflow.Context, input *kafka.ListClustersInput) (*kafka.ListClustersOutput, error) {
	var output kafka.ListClustersOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.ListClusters", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) ListClustersAsync(ctx workflow.Context, input *kafka.ListClustersInput) *KafkaListClustersFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.ListClusters", input)
	return &KafkaListClustersFuture{Future: future}
}

func (a *stub) ListConfigurationRevisions(ctx workflow.Context, input *kafka.ListConfigurationRevisionsInput) (*kafka.ListConfigurationRevisionsOutput, error) {
	var output kafka.ListConfigurationRevisionsOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.ListConfigurationRevisions", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) ListConfigurationRevisionsAsync(ctx workflow.Context, input *kafka.ListConfigurationRevisionsInput) *KafkaListConfigurationRevisionsFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.ListConfigurationRevisions", input)
	return &KafkaListConfigurationRevisionsFuture{Future: future}
}

func (a *stub) ListConfigurations(ctx workflow.Context, input *kafka.ListConfigurationsInput) (*kafka.ListConfigurationsOutput, error) {
	var output kafka.ListConfigurationsOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.ListConfigurations", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) ListConfigurationsAsync(ctx workflow.Context, input *kafka.ListConfigurationsInput) *KafkaListConfigurationsFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.ListConfigurations", input)
	return &KafkaListConfigurationsFuture{Future: future}
}

func (a *stub) ListKafkaVersions(ctx workflow.Context, input *kafka.ListKafkaVersionsInput) (*kafka.ListKafkaVersionsOutput, error) {
	var output kafka.ListKafkaVersionsOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.ListKafkaVersions", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) ListKafkaVersionsAsync(ctx workflow.Context, input *kafka.ListKafkaVersionsInput) *KafkaListKafkaVersionsFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.ListKafkaVersions", input)
	return &KafkaListKafkaVersionsFuture{Future: future}
}

func (a *stub) ListNodes(ctx workflow.Context, input *kafka.ListNodesInput) (*kafka.ListNodesOutput, error) {
	var output kafka.ListNodesOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.ListNodes", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) ListNodesAsync(ctx workflow.Context, input *kafka.ListNodesInput) *KafkaListNodesFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.ListNodes", input)
	return &KafkaListNodesFuture{Future: future}
}

func (a *stub) ListScramSecrets(ctx workflow.Context, input *kafka.ListScramSecretsInput) (*kafka.ListScramSecretsOutput, error) {
	var output kafka.ListScramSecretsOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.ListScramSecrets", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) ListScramSecretsAsync(ctx workflow.Context, input *kafka.ListScramSecretsInput) *KafkaListScramSecretsFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.ListScramSecrets", input)
	return &KafkaListScramSecretsFuture{Future: future}
}

func (a *stub) ListTagsForResource(ctx workflow.Context, input *kafka.ListTagsForResourceInput) (*kafka.ListTagsForResourceOutput, error) {
	var output kafka.ListTagsForResourceOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.ListTagsForResource", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) ListTagsForResourceAsync(ctx workflow.Context, input *kafka.ListTagsForResourceInput) *KafkaListTagsForResourceFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.ListTagsForResource", input)
	return &KafkaListTagsForResourceFuture{Future: future}
}

func (a *stub) RebootBroker(ctx workflow.Context, input *kafka.RebootBrokerInput) (*kafka.RebootBrokerOutput, error) {
	var output kafka.RebootBrokerOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.RebootBroker", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) RebootBrokerAsync(ctx workflow.Context, input *kafka.RebootBrokerInput) *KafkaRebootBrokerFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.RebootBroker", input)
	return &KafkaRebootBrokerFuture{Future: future}
}

func (a *stub) TagResource(ctx workflow.Context, input *kafka.TagResourceInput) (*kafka.TagResourceOutput, error) {
	var output kafka.TagResourceOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.TagResource", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) TagResourceAsync(ctx workflow.Context, input *kafka.TagResourceInput) *KafkaTagResourceFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.TagResource", input)
	return &KafkaTagResourceFuture{Future: future}
}

func (a *stub) UntagResource(ctx workflow.Context, input *kafka.UntagResourceInput) (*kafka.UntagResourceOutput, error) {
	var output kafka.UntagResourceOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.UntagResource", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) UntagResourceAsync(ctx workflow.Context, input *kafka.UntagResourceInput) *KafkaUntagResourceFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.UntagResource", input)
	return &KafkaUntagResourceFuture{Future: future}
}

func (a *stub) UpdateBrokerCount(ctx workflow.Context, input *kafka.UpdateBrokerCountInput) (*kafka.UpdateBrokerCountOutput, error) {
	var output kafka.UpdateBrokerCountOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.UpdateBrokerCount", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) UpdateBrokerCountAsync(ctx workflow.Context, input *kafka.UpdateBrokerCountInput) *KafkaUpdateBrokerCountFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.UpdateBrokerCount", input)
	return &KafkaUpdateBrokerCountFuture{Future: future}
}

func (a *stub) UpdateBrokerStorage(ctx workflow.Context, input *kafka.UpdateBrokerStorageInput) (*kafka.UpdateBrokerStorageOutput, error) {
	var output kafka.UpdateBrokerStorageOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.UpdateBrokerStorage", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) UpdateBrokerStorageAsync(ctx workflow.Context, input *kafka.UpdateBrokerStorageInput) *KafkaUpdateBrokerStorageFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.UpdateBrokerStorage", input)
	return &KafkaUpdateBrokerStorageFuture{Future: future}
}

func (a *stub) UpdateClusterConfiguration(ctx workflow.Context, input *kafka.UpdateClusterConfigurationInput) (*kafka.UpdateClusterConfigurationOutput, error) {
	var output kafka.UpdateClusterConfigurationOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.UpdateClusterConfiguration", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) UpdateClusterConfigurationAsync(ctx workflow.Context, input *kafka.UpdateClusterConfigurationInput) *KafkaUpdateClusterConfigurationFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.UpdateClusterConfiguration", input)
	return &KafkaUpdateClusterConfigurationFuture{Future: future}
}

func (a *stub) UpdateClusterKafkaVersion(ctx workflow.Context, input *kafka.UpdateClusterKafkaVersionInput) (*kafka.UpdateClusterKafkaVersionOutput, error) {
	var output kafka.UpdateClusterKafkaVersionOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.UpdateClusterKafkaVersion", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) UpdateClusterKafkaVersionAsync(ctx workflow.Context, input *kafka.UpdateClusterKafkaVersionInput) *KafkaUpdateClusterKafkaVersionFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.UpdateClusterKafkaVersion", input)
	return &KafkaUpdateClusterKafkaVersionFuture{Future: future}
}

func (a *stub) UpdateConfiguration(ctx workflow.Context, input *kafka.UpdateConfigurationInput) (*kafka.UpdateConfigurationOutput, error) {
	var output kafka.UpdateConfigurationOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.UpdateConfiguration", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) UpdateConfigurationAsync(ctx workflow.Context, input *kafka.UpdateConfigurationInput) *KafkaUpdateConfigurationFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.UpdateConfiguration", input)
	return &KafkaUpdateConfigurationFuture{Future: future}
}

func (a *stub) UpdateMonitoring(ctx workflow.Context, input *kafka.UpdateMonitoringInput) (*kafka.UpdateMonitoringOutput, error) {
	var output kafka.UpdateMonitoringOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.UpdateMonitoring", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) UpdateMonitoringAsync(ctx workflow.Context, input *kafka.UpdateMonitoringInput) *KafkaUpdateMonitoringFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.UpdateMonitoring", input)
	return &KafkaUpdateMonitoringFuture{Future: future}
}
