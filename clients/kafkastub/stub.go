// Generated by github.com/temporalio/temporal-aws-sdk-generator
// from github.com/aws/aws-sdk-go version 1.35.7
// Copyright (c) 2020 Temporal Technologies Inc.  All rights reserved.

package kafkastub

import (
	"github.com/aws/aws-sdk-go/service/kafka"
	"go.temporal.io/sdk/workflow"

	"go.temporal.io/aws-sdk/clients"
)

// ensure that imports are valid even if not used by the generated code
var _ clients.VoidFuture

type stub struct{}

type BatchAssociateScramSecretFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *BatchAssociateScramSecretFuture) Get(ctx workflow.Context) (*kafka.BatchAssociateScramSecretOutput, error) {
	var output kafka.BatchAssociateScramSecretOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type BatchDisassociateScramSecretFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *BatchDisassociateScramSecretFuture) Get(ctx workflow.Context) (*kafka.BatchDisassociateScramSecretOutput, error) {
	var output kafka.BatchDisassociateScramSecretOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type CreateClusterFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *CreateClusterFuture) Get(ctx workflow.Context) (*kafka.CreateClusterOutput, error) {
	var output kafka.CreateClusterOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type CreateConfigurationFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *CreateConfigurationFuture) Get(ctx workflow.Context) (*kafka.CreateConfigurationOutput, error) {
	var output kafka.CreateConfigurationOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type DeleteClusterFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *DeleteClusterFuture) Get(ctx workflow.Context) (*kafka.DeleteClusterOutput, error) {
	var output kafka.DeleteClusterOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type DeleteConfigurationFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *DeleteConfigurationFuture) Get(ctx workflow.Context) (*kafka.DeleteConfigurationOutput, error) {
	var output kafka.DeleteConfigurationOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type DescribeClusterFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *DescribeClusterFuture) Get(ctx workflow.Context) (*kafka.DescribeClusterOutput, error) {
	var output kafka.DescribeClusterOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type DescribeClusterOperationFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *DescribeClusterOperationFuture) Get(ctx workflow.Context) (*kafka.DescribeClusterOperationOutput, error) {
	var output kafka.DescribeClusterOperationOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type DescribeConfigurationFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *DescribeConfigurationFuture) Get(ctx workflow.Context) (*kafka.DescribeConfigurationOutput, error) {
	var output kafka.DescribeConfigurationOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type DescribeConfigurationRevisionFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *DescribeConfigurationRevisionFuture) Get(ctx workflow.Context) (*kafka.DescribeConfigurationRevisionOutput, error) {
	var output kafka.DescribeConfigurationRevisionOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type GetBootstrapBrokersFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *GetBootstrapBrokersFuture) Get(ctx workflow.Context) (*kafka.GetBootstrapBrokersOutput, error) {
	var output kafka.GetBootstrapBrokersOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type GetCompatibleKafkaVersionsFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *GetCompatibleKafkaVersionsFuture) Get(ctx workflow.Context) (*kafka.GetCompatibleKafkaVersionsOutput, error) {
	var output kafka.GetCompatibleKafkaVersionsOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type ListClusterOperationsFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *ListClusterOperationsFuture) Get(ctx workflow.Context) (*kafka.ListClusterOperationsOutput, error) {
	var output kafka.ListClusterOperationsOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type ListClustersFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *ListClustersFuture) Get(ctx workflow.Context) (*kafka.ListClustersOutput, error) {
	var output kafka.ListClustersOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type ListConfigurationRevisionsFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *ListConfigurationRevisionsFuture) Get(ctx workflow.Context) (*kafka.ListConfigurationRevisionsOutput, error) {
	var output kafka.ListConfigurationRevisionsOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type ListConfigurationsFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *ListConfigurationsFuture) Get(ctx workflow.Context) (*kafka.ListConfigurationsOutput, error) {
	var output kafka.ListConfigurationsOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type ListKafkaVersionsFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *ListKafkaVersionsFuture) Get(ctx workflow.Context) (*kafka.ListKafkaVersionsOutput, error) {
	var output kafka.ListKafkaVersionsOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type ListNodesFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *ListNodesFuture) Get(ctx workflow.Context) (*kafka.ListNodesOutput, error) {
	var output kafka.ListNodesOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type ListScramSecretsFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *ListScramSecretsFuture) Get(ctx workflow.Context) (*kafka.ListScramSecretsOutput, error) {
	var output kafka.ListScramSecretsOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type ListTagsForResourceFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *ListTagsForResourceFuture) Get(ctx workflow.Context) (*kafka.ListTagsForResourceOutput, error) {
	var output kafka.ListTagsForResourceOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type RebootBrokerFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *RebootBrokerFuture) Get(ctx workflow.Context) (*kafka.RebootBrokerOutput, error) {
	var output kafka.RebootBrokerOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type TagResourceFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *TagResourceFuture) Get(ctx workflow.Context) (*kafka.TagResourceOutput, error) {
	var output kafka.TagResourceOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type UntagResourceFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *UntagResourceFuture) Get(ctx workflow.Context) (*kafka.UntagResourceOutput, error) {
	var output kafka.UntagResourceOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type UpdateBrokerCountFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *UpdateBrokerCountFuture) Get(ctx workflow.Context) (*kafka.UpdateBrokerCountOutput, error) {
	var output kafka.UpdateBrokerCountOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type UpdateBrokerStorageFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *UpdateBrokerStorageFuture) Get(ctx workflow.Context) (*kafka.UpdateBrokerStorageOutput, error) {
	var output kafka.UpdateBrokerStorageOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type UpdateClusterConfigurationFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *UpdateClusterConfigurationFuture) Get(ctx workflow.Context) (*kafka.UpdateClusterConfigurationOutput, error) {
	var output kafka.UpdateClusterConfigurationOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type UpdateClusterKafkaVersionFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *UpdateClusterKafkaVersionFuture) Get(ctx workflow.Context) (*kafka.UpdateClusterKafkaVersionOutput, error) {
	var output kafka.UpdateClusterKafkaVersionOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type UpdateConfigurationFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *UpdateConfigurationFuture) Get(ctx workflow.Context) (*kafka.UpdateConfigurationOutput, error) {
	var output kafka.UpdateConfigurationOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

type UpdateMonitoringFuture struct {
	// public to support Selector.addFuture
	Future workflow.Future
}

func (r *UpdateMonitoringFuture) Get(ctx workflow.Context) (*kafka.UpdateMonitoringOutput, error) {
	var output kafka.UpdateMonitoringOutput
	err := r.Future.Get(ctx, &output)
	return &output, err
}

func (a *stub) BatchAssociateScramSecret(ctx workflow.Context, input *kafka.BatchAssociateScramSecretInput) (*kafka.BatchAssociateScramSecretOutput, error) {
	var output kafka.BatchAssociateScramSecretOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.BatchAssociateScramSecret", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) BatchAssociateScramSecretAsync(ctx workflow.Context, input *kafka.BatchAssociateScramSecretInput) *BatchAssociateScramSecretFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.BatchAssociateScramSecret", input)
	return &BatchAssociateScramSecretFuture{Future: future}
}

func (a *stub) BatchDisassociateScramSecret(ctx workflow.Context, input *kafka.BatchDisassociateScramSecretInput) (*kafka.BatchDisassociateScramSecretOutput, error) {
	var output kafka.BatchDisassociateScramSecretOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.BatchDisassociateScramSecret", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) BatchDisassociateScramSecretAsync(ctx workflow.Context, input *kafka.BatchDisassociateScramSecretInput) *BatchDisassociateScramSecretFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.BatchDisassociateScramSecret", input)
	return &BatchDisassociateScramSecretFuture{Future: future}
}

func (a *stub) CreateCluster(ctx workflow.Context, input *kafka.CreateClusterInput) (*kafka.CreateClusterOutput, error) {
	var output kafka.CreateClusterOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.CreateCluster", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) CreateClusterAsync(ctx workflow.Context, input *kafka.CreateClusterInput) *CreateClusterFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.CreateCluster", input)
	return &CreateClusterFuture{Future: future}
}

func (a *stub) CreateConfiguration(ctx workflow.Context, input *kafka.CreateConfigurationInput) (*kafka.CreateConfigurationOutput, error) {
	var output kafka.CreateConfigurationOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.CreateConfiguration", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) CreateConfigurationAsync(ctx workflow.Context, input *kafka.CreateConfigurationInput) *CreateConfigurationFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.CreateConfiguration", input)
	return &CreateConfigurationFuture{Future: future}
}

func (a *stub) DeleteCluster(ctx workflow.Context, input *kafka.DeleteClusterInput) (*kafka.DeleteClusterOutput, error) {
	var output kafka.DeleteClusterOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.DeleteCluster", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) DeleteClusterAsync(ctx workflow.Context, input *kafka.DeleteClusterInput) *DeleteClusterFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.DeleteCluster", input)
	return &DeleteClusterFuture{Future: future}
}

func (a *stub) DeleteConfiguration(ctx workflow.Context, input *kafka.DeleteConfigurationInput) (*kafka.DeleteConfigurationOutput, error) {
	var output kafka.DeleteConfigurationOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.DeleteConfiguration", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) DeleteConfigurationAsync(ctx workflow.Context, input *kafka.DeleteConfigurationInput) *DeleteConfigurationFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.DeleteConfiguration", input)
	return &DeleteConfigurationFuture{Future: future}
}

func (a *stub) DescribeCluster(ctx workflow.Context, input *kafka.DescribeClusterInput) (*kafka.DescribeClusterOutput, error) {
	var output kafka.DescribeClusterOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.DescribeCluster", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) DescribeClusterAsync(ctx workflow.Context, input *kafka.DescribeClusterInput) *DescribeClusterFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.DescribeCluster", input)
	return &DescribeClusterFuture{Future: future}
}

func (a *stub) DescribeClusterOperation(ctx workflow.Context, input *kafka.DescribeClusterOperationInput) (*kafka.DescribeClusterOperationOutput, error) {
	var output kafka.DescribeClusterOperationOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.DescribeClusterOperation", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) DescribeClusterOperationAsync(ctx workflow.Context, input *kafka.DescribeClusterOperationInput) *DescribeClusterOperationFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.DescribeClusterOperation", input)
	return &DescribeClusterOperationFuture{Future: future}
}

func (a *stub) DescribeConfiguration(ctx workflow.Context, input *kafka.DescribeConfigurationInput) (*kafka.DescribeConfigurationOutput, error) {
	var output kafka.DescribeConfigurationOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.DescribeConfiguration", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) DescribeConfigurationAsync(ctx workflow.Context, input *kafka.DescribeConfigurationInput) *DescribeConfigurationFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.DescribeConfiguration", input)
	return &DescribeConfigurationFuture{Future: future}
}

func (a *stub) DescribeConfigurationRevision(ctx workflow.Context, input *kafka.DescribeConfigurationRevisionInput) (*kafka.DescribeConfigurationRevisionOutput, error) {
	var output kafka.DescribeConfigurationRevisionOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.DescribeConfigurationRevision", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) DescribeConfigurationRevisionAsync(ctx workflow.Context, input *kafka.DescribeConfigurationRevisionInput) *DescribeConfigurationRevisionFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.DescribeConfigurationRevision", input)
	return &DescribeConfigurationRevisionFuture{Future: future}
}

func (a *stub) GetBootstrapBrokers(ctx workflow.Context, input *kafka.GetBootstrapBrokersInput) (*kafka.GetBootstrapBrokersOutput, error) {
	var output kafka.GetBootstrapBrokersOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.GetBootstrapBrokers", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) GetBootstrapBrokersAsync(ctx workflow.Context, input *kafka.GetBootstrapBrokersInput) *GetBootstrapBrokersFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.GetBootstrapBrokers", input)
	return &GetBootstrapBrokersFuture{Future: future}
}

func (a *stub) GetCompatibleKafkaVersions(ctx workflow.Context, input *kafka.GetCompatibleKafkaVersionsInput) (*kafka.GetCompatibleKafkaVersionsOutput, error) {
	var output kafka.GetCompatibleKafkaVersionsOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.GetCompatibleKafkaVersions", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) GetCompatibleKafkaVersionsAsync(ctx workflow.Context, input *kafka.GetCompatibleKafkaVersionsInput) *GetCompatibleKafkaVersionsFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.GetCompatibleKafkaVersions", input)
	return &GetCompatibleKafkaVersionsFuture{Future: future}
}

func (a *stub) ListClusterOperations(ctx workflow.Context, input *kafka.ListClusterOperationsInput) (*kafka.ListClusterOperationsOutput, error) {
	var output kafka.ListClusterOperationsOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.ListClusterOperations", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) ListClusterOperationsAsync(ctx workflow.Context, input *kafka.ListClusterOperationsInput) *ListClusterOperationsFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.ListClusterOperations", input)
	return &ListClusterOperationsFuture{Future: future}
}

func (a *stub) ListClusters(ctx workflow.Context, input *kafka.ListClustersInput) (*kafka.ListClustersOutput, error) {
	var output kafka.ListClustersOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.ListClusters", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) ListClustersAsync(ctx workflow.Context, input *kafka.ListClustersInput) *ListClustersFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.ListClusters", input)
	return &ListClustersFuture{Future: future}
}

func (a *stub) ListConfigurationRevisions(ctx workflow.Context, input *kafka.ListConfigurationRevisionsInput) (*kafka.ListConfigurationRevisionsOutput, error) {
	var output kafka.ListConfigurationRevisionsOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.ListConfigurationRevisions", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) ListConfigurationRevisionsAsync(ctx workflow.Context, input *kafka.ListConfigurationRevisionsInput) *ListConfigurationRevisionsFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.ListConfigurationRevisions", input)
	return &ListConfigurationRevisionsFuture{Future: future}
}

func (a *stub) ListConfigurations(ctx workflow.Context, input *kafka.ListConfigurationsInput) (*kafka.ListConfigurationsOutput, error) {
	var output kafka.ListConfigurationsOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.ListConfigurations", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) ListConfigurationsAsync(ctx workflow.Context, input *kafka.ListConfigurationsInput) *ListConfigurationsFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.ListConfigurations", input)
	return &ListConfigurationsFuture{Future: future}
}

func (a *stub) ListKafkaVersions(ctx workflow.Context, input *kafka.ListKafkaVersionsInput) (*kafka.ListKafkaVersionsOutput, error) {
	var output kafka.ListKafkaVersionsOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.ListKafkaVersions", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) ListKafkaVersionsAsync(ctx workflow.Context, input *kafka.ListKafkaVersionsInput) *ListKafkaVersionsFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.ListKafkaVersions", input)
	return &ListKafkaVersionsFuture{Future: future}
}

func (a *stub) ListNodes(ctx workflow.Context, input *kafka.ListNodesInput) (*kafka.ListNodesOutput, error) {
	var output kafka.ListNodesOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.ListNodes", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) ListNodesAsync(ctx workflow.Context, input *kafka.ListNodesInput) *ListNodesFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.ListNodes", input)
	return &ListNodesFuture{Future: future}
}

func (a *stub) ListScramSecrets(ctx workflow.Context, input *kafka.ListScramSecretsInput) (*kafka.ListScramSecretsOutput, error) {
	var output kafka.ListScramSecretsOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.ListScramSecrets", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) ListScramSecretsAsync(ctx workflow.Context, input *kafka.ListScramSecretsInput) *ListScramSecretsFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.ListScramSecrets", input)
	return &ListScramSecretsFuture{Future: future}
}

func (a *stub) ListTagsForResource(ctx workflow.Context, input *kafka.ListTagsForResourceInput) (*kafka.ListTagsForResourceOutput, error) {
	var output kafka.ListTagsForResourceOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.ListTagsForResource", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) ListTagsForResourceAsync(ctx workflow.Context, input *kafka.ListTagsForResourceInput) *ListTagsForResourceFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.ListTagsForResource", input)
	return &ListTagsForResourceFuture{Future: future}
}

func (a *stub) RebootBroker(ctx workflow.Context, input *kafka.RebootBrokerInput) (*kafka.RebootBrokerOutput, error) {
	var output kafka.RebootBrokerOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.RebootBroker", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) RebootBrokerAsync(ctx workflow.Context, input *kafka.RebootBrokerInput) *RebootBrokerFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.RebootBroker", input)
	return &RebootBrokerFuture{Future: future}
}

func (a *stub) TagResource(ctx workflow.Context, input *kafka.TagResourceInput) (*kafka.TagResourceOutput, error) {
	var output kafka.TagResourceOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.TagResource", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) TagResourceAsync(ctx workflow.Context, input *kafka.TagResourceInput) *TagResourceFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.TagResource", input)
	return &TagResourceFuture{Future: future}
}

func (a *stub) UntagResource(ctx workflow.Context, input *kafka.UntagResourceInput) (*kafka.UntagResourceOutput, error) {
	var output kafka.UntagResourceOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.UntagResource", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) UntagResourceAsync(ctx workflow.Context, input *kafka.UntagResourceInput) *UntagResourceFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.UntagResource", input)
	return &UntagResourceFuture{Future: future}
}

func (a *stub) UpdateBrokerCount(ctx workflow.Context, input *kafka.UpdateBrokerCountInput) (*kafka.UpdateBrokerCountOutput, error) {
	var output kafka.UpdateBrokerCountOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.UpdateBrokerCount", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) UpdateBrokerCountAsync(ctx workflow.Context, input *kafka.UpdateBrokerCountInput) *UpdateBrokerCountFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.UpdateBrokerCount", input)
	return &UpdateBrokerCountFuture{Future: future}
}

func (a *stub) UpdateBrokerStorage(ctx workflow.Context, input *kafka.UpdateBrokerStorageInput) (*kafka.UpdateBrokerStorageOutput, error) {
	var output kafka.UpdateBrokerStorageOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.UpdateBrokerStorage", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) UpdateBrokerStorageAsync(ctx workflow.Context, input *kafka.UpdateBrokerStorageInput) *UpdateBrokerStorageFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.UpdateBrokerStorage", input)
	return &UpdateBrokerStorageFuture{Future: future}
}

func (a *stub) UpdateClusterConfiguration(ctx workflow.Context, input *kafka.UpdateClusterConfigurationInput) (*kafka.UpdateClusterConfigurationOutput, error) {
	var output kafka.UpdateClusterConfigurationOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.UpdateClusterConfiguration", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) UpdateClusterConfigurationAsync(ctx workflow.Context, input *kafka.UpdateClusterConfigurationInput) *UpdateClusterConfigurationFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.UpdateClusterConfiguration", input)
	return &UpdateClusterConfigurationFuture{Future: future}
}

func (a *stub) UpdateClusterKafkaVersion(ctx workflow.Context, input *kafka.UpdateClusterKafkaVersionInput) (*kafka.UpdateClusterKafkaVersionOutput, error) {
	var output kafka.UpdateClusterKafkaVersionOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.UpdateClusterKafkaVersion", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) UpdateClusterKafkaVersionAsync(ctx workflow.Context, input *kafka.UpdateClusterKafkaVersionInput) *UpdateClusterKafkaVersionFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.UpdateClusterKafkaVersion", input)
	return &UpdateClusterKafkaVersionFuture{Future: future}
}

func (a *stub) UpdateConfiguration(ctx workflow.Context, input *kafka.UpdateConfigurationInput) (*kafka.UpdateConfigurationOutput, error) {
	var output kafka.UpdateConfigurationOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.UpdateConfiguration", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) UpdateConfigurationAsync(ctx workflow.Context, input *kafka.UpdateConfigurationInput) *UpdateConfigurationFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.UpdateConfiguration", input)
	return &UpdateConfigurationFuture{Future: future}
}

func (a *stub) UpdateMonitoring(ctx workflow.Context, input *kafka.UpdateMonitoringInput) (*kafka.UpdateMonitoringOutput, error) {
	var output kafka.UpdateMonitoringOutput
	err := workflow.ExecuteActivity(ctx, "aws.kafka.UpdateMonitoring", input).Get(ctx, &output)
	return &output, err
}

func (a *stub) UpdateMonitoringAsync(ctx workflow.Context, input *kafka.UpdateMonitoringInput) *UpdateMonitoringFuture {
	future := workflow.ExecuteActivity(ctx, "aws.kafka.UpdateMonitoring", input)
	return &UpdateMonitoringFuture{Future: future}
}
